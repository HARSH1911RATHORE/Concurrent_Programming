/* reference: https://www.geeksforgeeks.org/quick-sort/ */
/* reference: https://www.geeksforgeeks.org/merge-sort/ */
/* reference: https://www.youtube.com/watch?v=TzeBrDU-JaY */
/* reference: https://www.youtube.com/watch?v=COk73cpQbFQ */
/* reference: https://www.youtube.com/watch?v=3Bbm3Prd5Fo */
/* reference: https://www.youtube.com/watch?v=0nlPxaC2lTw */
/* reference: https://linux.die.net/man/3/getopt */
/* reference: test.c provided by professor */
/*reference: https://www.geeksforgeeks.org/map-insert-in-c-stl/ */
/*reference: https://www.tutorialspoint.com/cplusplus-program-to-implement-bucket-sort */

/*C LIBRARY HEADER FILES*/
#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <math.h>
#include <bits/stdc++.h> 

/*C++ LIBRARY HEADER FILES*/
#include <iostream>
#include <cmath>
#include <vector>
#include <algorithm>
#include <set> 
#include <iterator> 

using namespace std;

int count_lock=0;
int count_lock_get=0;

#define LMAX 255                /*to read the input file */

char *non_option_argument;  /*unsorted file.txt which will be passed as command line argument*/
char *put_file;          /*file to which the sorted elements from the unsorted array will be put*/
char *get_file;          /*file to which the sorted elements from the unsorted array will be put*/
char *range_file;          /*file to which the sorted elements from the unsorted array will be put*/

int idx = 0;                /* index of array of no of lines  */
int rw_lock_flag = 0;         /*if algo selected for sorting the unsorted file is merge, merge flag will be 1*/
int fg_lock_flag = 0;         /*if algo selected for sorting the unsorted file is quick, merge flag will be 1*/
int thread_count = 0;       /*count of number of threads used*/

struct timespec start, end_time;    /*calculate time at start and end of thread*/
// pthread_mutex_t fg_lock; /*initialize the mutex lock*/

pthread_rwlock_t lock_rw_function;

pthread_mutex_t lock_fg_function; /*initialize the mutex lock*/

pthread_mutex_t global_lock;

typedef struct Node_rw 
{
    pthread_rwlock_t lock;
    int key;
    int value;
    struct Node_rw *left;
    struct Node_rw *right;
    
}Node_rw;

typedef struct rw_range 
{ 
   int key_begin;
   int key_last;
   Node_rw *node;
}size_rw_range_info; 
vector <size_rw_range_info> range_info_rw_function[2];


typedef struct Tree_rw 
{
    pthread_rwlock_t lock;
    Node_rw *root  ;
}Tree_rw;

Tree_rw *tree_rw = NULL;

size_t it = 0;              /*  variable iterator  */

typedef struct data_thread_iterations
{
	int iteration_number;
	int iteration_length;
	int iteration_item;
}data_thread_iterations;

typedef struct node 
{ 
    pthread_mutex_t lock;
    int key; 
    int value;
    struct node *left, *right; 
}Node;



typedef struct Tree 
{
    pthread_mutex_t lock;
    Node *root  ;
}Tree;

Tree *tree;

typedef struct fg_range 
{ 
   int key_begin;
   int key_last;
   Node *node;
}size_fg_range_info; 
vector <size_fg_range_info> range_info_fg_function[2];
// Node *global_root =   NULL;
// A utility function to create a new BST node 
Node* newNode(int item, int val) 
{ 
    Node* temp 
        = (Node*)malloc(sizeof(Node)); 
    temp->key = item; 
    temp->value = val; 
    temp->left = temp->right = NULL; 
    return temp; 
} 


void insert_helper_rw(Node_rw *root, int key, int value, Node_rw *parent) 
{
    if (root) 
    {
        // lock(root->lock);
        pthread_rwlock_wrlock(&root->lock);
        if (parent) pthread_rwlock_unlock(&parent->lock);
        if (root->key > key) 
        {
            if (root->left) 
            {
                insert_helper_rw(root->left, key, value, root);
            } 
            else 
            {
                Node_rw *n = (Node_rw*)malloc(sizeof(Node_rw));
                pthread_rwlock_init(&n->lock, NULL);
                n->key = key;
                n->value = value;
                n->left = NULL;
                n->right = NULL;
                root->left = n;
                // unlock(root->lock);
                pthread_rwlock_unlock(&root->lock);
            }
        } 
        else if (root->key < key)
        {
            if (root->right) 
            {
                insert_helper_rw(root->right,key, value, root);
            } 
            else 
            {
                Node_rw *n = (Node_rw*)malloc(sizeof(Node_rw));
                pthread_rwlock_init(&n->lock, NULL);
                n->value = value;
                n->key = key;
                n->left = NULL;
                n->right = NULL;
                root->right = n;
               // unlock(root->lock);
                pthread_rwlock_unlock(&root->lock);
            }
        } 
        else 
        {
            // do nothing, value exists
           // unlock(root->lock);
            root->value = value;
            pthread_rwlock_unlock(&root->lock);
            return;
        }
    }
}

void insert_rw(Tree_rw *tree, int key, int value) 
{

    // Case 1: tree is empty
    // lock(tree->lock);
    pthread_rwlock_wrlock(&tree->lock);

    if (!tree->root) 
    {
        Node_rw *n = (Node_rw*)malloc(sizeof(Node_rw));
        pthread_rwlock_init(&n->lock, NULL);
        n->value = value;
        n->key = key;
        n->left = NULL;
        n->right = NULL;
        tree->root = n;
        pthread_rwlock_unlock(&tree->lock);
        // unlock(tree->lock);
        return;
    }

    // Case 2: Tree is non-empty
    // unlock(tree->lock);
    pthread_rwlock_unlock(&tree->lock);
    insert_helper_rw(tree->root, key, value, NULL);
}

Node_rw * get_helper_rw(Node_rw *root, int key, Node_rw *parent)
{
    if (root) 
    {
        // lock(root->lock);
        pthread_rwlock_wrlock(&root->lock);
        if (parent) pthread_rwlock_unlock(&parent->lock);
        if (root->key > key) 
        {
            if (root->left) 
            {
                get_helper_rw(root->left, key, root);
            } 
            else 
            {
                pthread_rwlock_unlock(&root->lock);
                return NULL;
            }
        } 
        else if (root->key < key)
        {
            if (root->right) 
            {
                get_helper_rw(root->right,key, root);
            } 
            else 
            {
               pthread_rwlock_unlock(&root->lock);
               return NULL;
            }
        } 
        else 
        {
            // do nothing, value exists
           // unlock(root->lock);
            pthread_rwlock_unlock(&root->lock);
            return root;
        }
    }
}

Node_rw * get_rw(Tree_rw *tree, int key) 
{

    // Case 1: tree is empty
    // lock(tree->lock);
    pthread_rwlock_wrlock(&tree->lock);
    if (!tree->root) 
    {
        pthread_rwlock_unlock(&tree->lock);
        // unlock(tree->lock);
        return NULL;
    }

    // Case 2: Tree is non-empty
    // unlock(tree->lock);
    pthread_rwlock_unlock(&tree->lock);
    get_helper_rw(tree->root, key, NULL);
}

//fetch all the nodes in the given range
void get_nodes_inrange_rw(Node_rw *root, int key_begin, int key_last)
{
	if (root == NULL)
	{
		pthread_rwlock_wrlock(&lock_rw_function);
		if (tree_rw->root == NULL)
		{
			//printf("Searched failed for node with key %d\n", key);
			pthread_rwlock_unlock(&lock_rw_function);
			return;
		}
		pthread_rwlock_wrlock(&tree_rw->root->lock);
		root = tree_rw->root;
		pthread_rwlock_unlock(&lock_rw_function);
	}

	if (key_begin < root->key)
	{
		if (root->left != NULL)
		{
			pthread_rwlock_wrlock(&root->left->lock);
			pthread_rwlock_unlock(&root->lock);
			get_nodes_inrange_rw(root->left, key_begin, key_last);
			pthread_rwlock_wrlock(&root->lock);
		} 
		
	}

	if ((key_last >= root->key) && (key_begin <= root->key))
	{
		//printf("-->%d  %d to %d\n",tid, root->key, root->value);
		range_info_rw_function[0].push_back({key_begin, key_last, root});
	}
	
	if (key_last > root->key)
    {
        if (root->right != NULL)
        {
        	pthread_rwlock_wrlock(&root->right->lock);
        	pthread_rwlock_unlock(&root->lock);
        	get_nodes_inrange_rw(root->right, key_begin, key_last);
        	pthread_rwlock_wrlock(&root->lock);
        } 
    }
    pthread_rwlock_unlock(&root->lock);

}

void info_range_between_start_and_end_rw(Tree_rw *tree, int key_begin, int key_last)
{
	if (tree->root == NULL) 
    {
		return;
	}
	Node_rw *start_node = get_rw(tree, key_begin);
	Node_rw *end_node = get_rw(tree, key_last);

	if (start_node == NULL) 
    {
		printf("Error: Key starting with %d does not exist\n", key_begin);
	} 
    else if (end_node == NULL) 
    {
		printf("Error: Key ending with %d does not exist\n", key_last);
	} 
    else 
    {
		pthread_rwlock_wrlock(&lock_rw_function);
		pthread_rwlock_wrlock(&tree->root->lock);
		pthread_rwlock_unlock(&lock_rw_function);
		get_nodes_inrange_rw(tree->root, key_begin, key_last);
    }
}

Node_rw* getMin_rw(Node_rw *root, Node_rw *parent) 
{

    if (root) 
    {
        // lock(root->lock);
        pthread_rwlock_wrlock(&root->lock);
        // if (parent) unlock(parent->lock);
        if (parent) 
            pthread_rwlock_unlock(&parent->lock);
        
        if (root->left) 
        {
            return getMin_rw(root->left, root);
        } 
        else 
        {
            pthread_rwlock_unlock(&root->lock);
            // unlock(root->lock);
            return root;
        }
    } 
    else 
    {
        // Shouldn't happen
        
        return NULL;
    }
}

Node_rw *delete_helper_rw(Node_rw *root, int key, int value, Node_rw *parent) 
{
    if (root) 
    {
        pthread_rwlock_wrlock(&root->lock);
        if (root->key == key) 
        {
            // Case 1: root has no children
            if (!root->left && !root->right) 
            {
                Node_rw *tmp = root;
                root = NULL;
                // Modify parent after this node is fixed
                if (parent) 
                    pthread_rwlock_unlock(&parent->lock);

                pthread_rwlock_unlock(&tmp->lock);
                free(tmp);
                return root;
            }
            // Case 2: root has 1 child
            if (!root->left && root->right) 
            {
                Node_rw *tmp = root;
                root = root->right;
                // Modify parent after this node is fixed
                if (parent) 
                    pthread_rwlock_unlock(&parent->lock);

                pthread_rwlock_unlock(&tmp->lock);
                free(tmp);
                return root;
            }
            if (!root->right && root->left) 
            {
                Node_rw *tmp = root;
                root = root->left;
                // Modify parent after this node is fixed
                
                if (parent) 
                    pthread_rwlock_unlock(&parent->lock);
                pthread_rwlock_unlock(&tmp->lock);
                free(tmp);
                return root;
            }

            // Case 3: root has 2 children
            // Replace root with highest value smaller than root
            Node_rw *minRight = getMin_rw(root->right, NULL);
            root->key = minRight->key;
            // Now delete minRight node; set its parent's left child to NULL or
            // to minRight node's right child
            // We pass NULL as parent as we unlock root after deletion is complete
            root->right = delete_helper_rw(root->right, minRight->key, minRight->value, NULL);
            // Unlock after this sub-tree root is fixed to avoid violating
            // BST invariants when other threads insert simultaneously
            
            pthread_rwlock_unlock(&root->lock);
        }
        else if (root->key > key) 
        {
            // We can releas parent as we modify root and root->left now
            if (parent) 
                pthread_rwlock_unlock(&parent->lock);
            
            // Delete value node from left sub-tree
            root->left = delete_helper_rw(root->left, key, value, root);
        } else 
        {
            // We can releas parent as we modify root and root->right now
            if (parent) pthread_rwlock_unlock(&parent->lock);
            // Delete value node from right sub-tree
            root->right = delete_helper_rw(root->right, key, value, root);
        }
    } 
    else 
    {
        // Nothing to delete
        return root;
    }
}

void deleteid_rw(Tree_rw *tree, int key, int value) {

    // Case 1: tree is empty
    pthread_rwlock_wrlock(&tree->lock);
    if (!tree->root)
    {
        pthread_rwlock_unlock(&tree->lock);
        return;
    }

    // Case 2: Tree is non-empty
    pthread_rwlock_unlock(&tree->lock);

    tree->root = delete_helper_rw(tree->root, key, value, NULL);
}


// A utility function to do inorder traversal of BST 
void print_nodes_inorder_rw(Node_rw* root) 
{ 
    if (root != NULL) { 
        print_nodes_inorder_rw(root->left); 
        printf("key_rw:%d value_rw:%d\n", root->key, root->value); 
        print_nodes_inorder_rw(root->right); 
    } 
} 

// A utility function to do inorder traversal of BST 
void print_nodes_inorder(Node* root) 
{ 
    if (root != NULL) { 
        print_nodes_inorder(root->left); 
        printf("key:%d value:%d\n", root->key, root->value); 
        print_nodes_inorder(root->right); 
    } 
} 

void update_value(Node *node, int value)
{
	node->value = value;
}


// //insert the key-value pair in the tree
// void insert(Node *root, int key, int value)
// {
// 	if (root == NULL)
// 	{
// 		pthread_mutex_lock(&lock_fg_function);  //rwlock_wrlock
// 		if (tree->root == NULL)
// 		{
// 			tree->root = newNode(key, value);
// 			printf("Root node initialized with key %d and value %d\n", tree->root->key, tree->root->value);
// 			pthread_mutex_unlock(&lock_fg_function);
// 			return;
// 		}

// 		pthread_mutex_lock(&tree->root->lock);
// 		root = tree->root;
// 		pthread_mutex_unlock(&lock_fg_function);
// 	}

// 	if (key < root->key)
// 	{
// 		if (root->left == NULL)
// 		{
// 			root->left = newNode(key, value);
// 			pthread_mutex_unlock(&root->lock);
// 		} else {
// 			pthread_mutex_lock(&root->left->lock);
// 			pthread_mutex_unlock(&root->lock);
// 			insert(root->left, key, value);
// 		}
// 	}
// 	else if (key > root->key)
//     {
//         if (root->right == NULL)
//         {
//             root->right = newNode(key, value);
//             pthread_mutex_unlock(&root->lock);
//         } else {
//             pthread_mutex_lock(&root->right->lock);
//             pthread_mutex_unlock(&root->lock);
//             insert(root->right, key, value);
//         }
//     } else {
// 		if (key == root->key)
// 			update_value(root, value);
// 		pthread_mutex_unlock(&root->lock);
// 	}
// }
////////~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void insert_helper(Node *root, int key, int value, Node *parent) 
{
    if (root) 
    {
        pthread_mutex_lock(&root->lock);
        count_lock++;
        if (parent) 
        {
            count_lock--;
            pthread_mutex_unlock(&parent->lock);
        }
        
        if (root->key > key) 
        {
            if (root->left) 
            {
                insert_helper(root->left, key, value, root);
            } 
            else 
            {
                Node *n = (Node*)malloc(sizeof(Node));
                pthread_mutex_init(&n->lock, NULL);
                n->key = key;
                n->value = value;
                n->left = NULL;
                n->right = NULL;
                root->left = n;
                count_lock--;
                pthread_mutex_unlock(&root->lock);
            }
        } 
        else if (root->key < key)
        {
            if (root->right) 
            {
                insert_helper(root->right,key, value, root);
            } 
            else 
            {
                Node *n = (Node*)malloc(sizeof(Node));
                pthread_mutex_init(&n->lock, NULL);
                n->value = value;
                n->key = key;
                n->left = NULL;
                n->right = NULL;
                root->right = n;
               count_lock--;
               pthread_mutex_unlock(&root->lock);
            }
        } 
        else 
        {
            root->value = value;
            count_lock--;
            pthread_mutex_unlock(&root->lock);
            return;
        }
    }
}

void insert(Tree *tree, int key, int value) 
{
    //  pthread_mutex_lock(&global_lock);
    // Case 1: tree is empty
    
    pthread_mutex_lock(&tree->lock);
            

    if (!tree->root) 
    {
        Node *n = (Node*)malloc(sizeof(Node));
        pthread_mutex_init(&n->lock, NULL);
        n->value = value;
        n->key = key;
        n->left = NULL;
        n->right = NULL;
        tree->root = n;
        pthread_mutex_unlock(&tree->lock);
        //  pthread_mutex_unlock(&global_lock);
        return;
    }

    // Case 2: Tree is non-empty
    pthread_mutex_unlock(&tree->lock);
    insert_helper(tree->root, key, value, NULL);

    //  pthread_mutex_unlock(&global_lock);
}

Node* get_helper ( Node* root, int key, Node* parent ) 
{
    if (root) 
    {
        pthread_mutex_lock(&root->lock);
        count_lock_get++;
        if (parent)
        {
            pthread_mutex_unlock(&parent->lock);
            count_lock_get--;
        }
        if (root->key > key) 
        {
            if (root->left) 
            {
                get_helper(root->left, key, root);
            } 
            else 
            {
                count_lock_get--;
                pthread_mutex_unlock(&root->lock);  
                return NULL;
            }
        } 
        else if (root->key < key)
        {
            if (root->right) 
            {
                get_helper(root->right,key, root);
            } 
            else 
            {
                count_lock_get--;
                pthread_mutex_unlock(&root->lock);
                return NULL;
            }
        } 
        else 
        {
            // do nothing, value exists
            count_lock_get--;
            pthread_mutex_unlock(&root->lock);
            return root;
        }
    }
}

Node * get(Tree *tree, int key) 
{
    // pthread_mutex_lock(&global_lock);
    // Case 1: tree is empty
    pthread_mutex_lock(&tree->lock);

    if (!tree->root) {

        pthread_mutex_unlock(&tree->lock);
        //  pthread_mutex_unlock(&global_lock);
        printf("value is null");
        return NULL;
    }

    // Case 2: Tree is non-empty
    pthread_mutex_unlock(&tree->lock);
    get_helper(tree->root, key, NULL);
    // pthread_mutex_unlock(&global_lock);
}


//fetch all the nodes in the given range
void get_nodes_inrange(Node *root, int key_begin, int key_last, int thread_number)
{
    // pthread_mutex_lock(&global_lock);
	if (root == NULL)
	{
		pthread_mutex_lock(&lock_fg_function);
		if (tree->root == NULL)
		{
			pthread_mutex_unlock(&lock_fg_function);
            // pthread_mutex_unlock(&global_lock);
			return;
		}

		pthread_mutex_lock(&tree->root->lock);
		root = tree->root;
		pthread_mutex_unlock(&lock_fg_function);
        // pthread_mutex_unlock(&global_lock);
	}

	if (key_begin < root->key)
	{
		if (root->left != NULL)
		{
			pthread_mutex_lock(&root->left->lock);
		    pthread_mutex_unlock(&root->lock);
			get_nodes_inrange(root->left, key_begin, key_last, thread_number);
			pthread_mutex_lock(&root->lock);
		} 
		
	}

	if ((key_begin <= root->key) && (key_last >= root->key))
	{
		//printf("-->%d  %d to %d\n",tid, root->key, root->value);
		range_info_fg_function[thread_number].push_back({key_begin, key_last, root});
	}
	
	if (key_last > root->key)
    {
        if (root->right != NULL)
        {
        	pthread_mutex_lock(&root->right->lock);
            pthread_mutex_unlock(&root->lock);
        	get_nodes_inrange(root->right, key_begin, key_last, thread_number);
        	pthread_mutex_lock(&root->lock);
        } 
    }

    pthread_mutex_unlock(&root->lock);
    // pthread_mutex_unlock(&global_lock);
}

void info_fg_range_between_start_and_end(Tree *tree, int key_begin, int key_last, int thread_number)
{
	if (tree->root == NULL) 
    {
		return;
	}

	Node *start_node = get(tree, key_begin);
	Node *end_node = get(tree, key_last);

	if (start_node == NULL) 
    {
		printf("Error: Key starting with %d does not exist\n", key_begin);
	} 
    else if (end_node == NULL) 
    {
		printf("Error: Key ending with %d does not exist\n", key_last);
	} 
    else 
    {
		pthread_mutex_lock(&lock_fg_function);
		pthread_mutex_lock(&tree->root->lock);
		pthread_mutex_unlock(&lock_fg_function);
		get_nodes_inrange(tree->root, key_begin, key_last, thread_number);
	}
}

Node* getMin(Node *root, Node *parent) 
{
    if (root) 
    {
        pthread_mutex_lock(&root->lock);
        if (parent) 
            pthread_mutex_unlock(&parent->lock);
        if (root->left) 
        {
            return getMin(root->left, root);
        } 
        else 
        {
            pthread_mutex_unlock(&root->lock);
            return root;
        }
    } 
    else 
    {
        // Shouldn't happen
        return NULL;
    }
}

Node *delete_helper(Node *root, int key, int value, Node *parent) 
{
    if (root) 
    {
        pthread_mutex_lock(&root->lock);
        if (root->key == key) 
        {
            // Case 1: root has no children
            if (!root->left && !root->right) 
            {
                Node *tmp = root;
                root = NULL;
                // Modify parent after this node is fixed
                if (parent) 
                    pthread_mutex_unlock(&parent->lock);
                
                pthread_mutex_unlock(&tmp->lock);
                free(tmp);
                return root;
            }

            // Case 2: root has 1 child
            if (!root->left && root->right) 
            {
                Node *tmp = root;
                root = root->right;
                // Modify parent after this node is fixed
                if (parent) 
                    pthread_mutex_unlock(&parent->lock);
                pthread_mutex_unlock(&tmp->lock);
                free(tmp);
                return root;
            }

            if (!root->right && root->left) 
            {
                Node *tmp = root;
                root = root->left;
                // Modify parent after this node is fixed
                if (parent) 
                    pthread_mutex_unlock(&parent->lock);
                pthread_mutex_unlock(&tmp->lock);
                free(tmp);
                return root;
            }
            // Case 3: root has 2 children
            // Replace root with highest value smaller than root
            Node *minRight = getMin(root->right, NULL);
            root->key = minRight->key;
            // Now delete minRight node; set its parent's left child to NULL or
            // to minRight node's right child
            // We pass NULL as parent as we unlock root after deletion is complete
            root->right = delete_helper(root->right, minRight->key, minRight->value, NULL);
            // Unlock after this sub-tree root is fixed to avoid violating
            // BST invariants when other threads insert simultaneously
            pthread_mutex_unlock(&root->lock);
        }
        else if (root->key > key) 
        {
            // We can releas parent as we modify root and root->left now
            if (parent) 
                pthread_mutex_unlock(&parent->lock);
            // Delete value node from left sub-tree
            root->left = delete_helper(root->left, key, value, root);
        } 
        else 
        {
            // We can releas parent as we modify root and root->right now
            if (parent) 
                pthread_mutex_unlock(&parent->lock);
            // Delete value node from right sub-tree
            root->right = delete_helper(root->right, key, value, root);
        }
    } 
    else
    {
        // Nothing to delete
        return root;
    }
}

void deleteid(Tree *tree, int key, int value) 
{
    // Case 1: tree is empty
    pthread_mutex_lock(&tree->lock);
    if (!tree->root)
    {
        pthread_mutex_unlock(&tree->lock);
        return;
    }

    // Case 2: Tree is non-empty
    pthread_mutex_unlock(&tree->lock);

    tree->root = delete_helper(tree->root, key, value, NULL);
}

/* UTILITY FUNCTIONS */
/* Function to print an array */
void printArray(int A[], int size) 
{ 
    int i; 
    for (i = 0; i < size; i++) 
        printf("%d ", A[i]); 
    printf("\n"); 
} 

void free_all_nodes_in_bst(Node *root)
{
	if (root != NULL) 
    {
        free_all_nodes_in_bst(root->right);
        free_all_nodes_in_bst(root->left);
        pthread_mutex_destroy(&root->lock);
        free(root);
    }
 }

//thread handler for put operation
void *put_handler_rw(void *arg)
{
	data_thread_iterations *th_info = (data_thread_iterations *)arg;
	int key = 0, value = 0, i = 0;

	FILE *file_ptr = fopen(put_file, "r");
	
	if (file_ptr == NULL) 
    {
		printf("ERROR: File could not be opened\n");
		exit(0);
	}

	while ((i < th_info->iteration_item) && (!feof (file_ptr))) 
    {
		fscanf(file_ptr, "%d %d\n", &key, &value);
		i++;
	}

	for (i = 0; i < th_info->iteration_length; i++)
	{
		fscanf(file_ptr, "%d %d\n", &key, &value);
		insert_rw(tree_rw, key, value);
	}	

	fclose(file_ptr);	

	return 0;
}

//thread handler for get operation
void *get_handler_rw(void *arg)
{
	data_thread_iterations *th_info = (data_thread_iterations *)arg;
	Node_rw *node;
	int key = 0, i = 0;

	FILE *file_ptr = fopen(get_file, "r");
	
	if (file_ptr == NULL) 
    {
		printf("ERROR: File could not be opened\n");
		exit(0);
	}

	while ((i < th_info->iteration_item) && (!feof (file_ptr))) 
    {
		fscanf(file_ptr, "%dn", &key);
		i++;
	}

	for (i = 0; i < th_info->iteration_length; i++)
	{
		fscanf(file_ptr, "%d\n", &key);

		node = get_rw(tree_rw, key);
		if (node == NULL) {
			printf("Node with key %d not found\n", key);
		} else {
			printf("Node with key %d contains value %d\n", node->key, node->value);
		}	
		node = NULL;
	}

    fclose(file_ptr);	

    return 0;
}

//thread handler for range querry operation
void *range_handler_rw(void *arg)
{
	data_thread_iterations *th_info = (data_thread_iterations *)arg;
    int key_begin = 0, key_last = 0, i = 0;

    FILE *file_ptr = fopen(range_file, "r");

    if (file_ptr == NULL) 
    {
		printf("ERROR: File could not be opened\n");
		exit(0);
	}

	while ((i < th_info->iteration_item) && (!feof (file_ptr))) 
    {
		fscanf(file_ptr, "%d %d\n", &key_begin, &key_last);
		i++;
	}

	for (i = 0; i < th_info->iteration_length; i++)
	{
		fscanf(file_ptr, "%d %d\n", &key_begin, &key_last);
		if (key_last > key_begin) {
			//printf("Invoking range query result for %d to %d\n", key_begin, key_last);
			get_nodes_inrange_rw(tree_rw->root, key_begin, key_last);
		}
	}

	fclose(file_ptr);

	return 0;
}

//thread handler for put operation
void *put_handler(void *arg)
{
	data_thread_iterations *th_info = (data_thread_iterations *)arg;
	int key = 0, value = 0, i = 0;

	FILE *file_ptr = fopen(put_file, "r");
	
	if (file_ptr == NULL) 
    {
		printf("ERROR: File could not be opened\n");
		exit(0);
	}

	while ((i < th_info->iteration_item) && (!feof (file_ptr))) 
    {
		fscanf(file_ptr, "%d %d\n", &key, &value);
        // printf("Task key ::: %d \n",th_info->iteration_item);
        // printf("Key:::%d    Valur:::%d \n",key,value);
		i++;
	}

	for (i = 0; i < th_info->iteration_length; i++)
	{
		fscanf(file_ptr, "%d %d\n", &key, &value);
        // printf("Keyssss:::%d    Valuesss:::%d \n",key,value);
		insert(tree, key, value);
	}	

	fclose(file_ptr);	

	return 0;
}

//thread handler for get operation
void *get_handler(void *arg)
{
	data_thread_iterations *th_info = (data_thread_iterations *)arg;
	Node *node;
	int key = 0, i = 0;

	FILE *file_ptr = fopen(get_file, "r");
	
	if (file_ptr == NULL) 
    {
		printf("ERROR: File could not be opened\n");
		exit(0);
	}

	while ((i < th_info->iteration_item) && (!feof (file_ptr))) 
    {
		fscanf(file_ptr, "%dn", &key);
		i++;
	}

	for (i = 0; i < th_info->iteration_length; i++)
	{
		fscanf(file_ptr, "%d\n", &key);

		node = get(tree, key);
		if (node == NULL) 
        {
			printf("Node with key %d not found\n", key);
		} 
        else
        {
			 printf("Node with key %d contains value %d\n", node->key, node->value);
		}	
		node = NULL;
	}

    fclose(file_ptr);	

    return 0;
}

//thread handler for range querry operation
void *range_handler(void *arg)
{
	data_thread_iterations *th_info = (data_thread_iterations *)arg;
    int key_begin = 0, key_last = 0, i = 0;

    FILE *file_ptr = fopen(range_file, "r");

    if (file_ptr == NULL) 
    {
		printf("ERROR: File could not be opened\n");
		exit(0);
	}

	while ((i < th_info->iteration_item) && (!feof (file_ptr))) 
    {
		fscanf(file_ptr, "%d %d\n", &key_begin, &key_last);
		i++;
	}

	for (i = 0; i < th_info->iteration_length; i++)
	{
		fscanf(file_ptr, "%d %d\n", &key_begin, &key_last);
		if (key_last > key_begin) {
			// printf("Invoking range query result for %d to %d\n", key_begin, key_last);
			get_nodes_inrange(tree->root, key_begin, key_last, th_info->iteration_number);
		}
	}

	fclose(file_ptr);

	return 0;
}

/* This function is used to read the input file and copy elements into the array */
int *file(char *required_file)
{
        char **array = NULL;        /* array of pointers to char        */ 
        char *ln = NULL;            /* NULL forces getline to allocate  */
        size_t n = 0;               /* buf size, 0 use getline default  */
        ssize_t nchr = 0;           /* number of chars actually read    */
        // size_t idx = 0;             /* array index for number of lines  */
        size_t lmax = LMAX;         /* current array pointer allocation */
        FILE *fp = NULL;            /* file pointer                     */
        if (! ( fp = fopen ( required_file, "r" ) ) ) 
        { /* open file for reading    */
            fprintf ( stderr, "error: file open failed " );
            return (int *)1;
        }

        /* allocate LMAX pointers and set to NULL. Each of the 255 pointers will
        point to (hold the address of) the beginning of each string read from
        the file below. This will allow access to each string with array[x].
        */
        if (!( array = (char**)calloc ( LMAX, sizeof * array ) ) ) 
        {
            fprintf ( stderr, "error: memory allocation failed." );
            return (int *)1;
        }

        /* prototype - ssize_t getline (char **ln, size_t *n, FILE *fp)
        above we declared: char *ln and size_t n. Why don't they match? Simple,
        we will be passing the address of each to getline, so we simply precede
        the variable with the urinary '&' which forces an addition level of
        dereference making char* char** and size_t size_t *. Now the arguments
        match the prototype.
        */
        while (( nchr = getline ( &ln, &n, fp )) != -1 )    /* read line    */
        {
            while ( nchr > 0 && ( ln[ nchr - 1 ] == '\n' || ln[ nchr - 1 ] == '\r' ) )
                ln[ --nchr ] = 0;     /* strip newline or carriage rtn    */

            /* allocate & copy ln to array - this will create a block of memory
            to hold each character in ln and copy the characters in ln to that
            memory address. The address will then be stored in array[idx].
            (idx++ just increases idx by 1 so it is ready for the next address) 
            There is a lot going on in that simple: array[idx++] = strdup (ln);
            */
            array[ idx++ ] = strdup ( ln );

            if ( idx == lmax ) {      /* if lmax lines reached, realloc   */
                char **tmp = (char**)realloc ( array, lmax * 2 * sizeof * array );
                if ( !tmp )
                    return (int *)-1;
                array = tmp;
                lmax *= 2;
            }
        }
        if ( fp ) 
            fclose ( fp );        /* close file */
        if ( ln ) 
            free ( ln );          /* free memory allocated to ln  */

        int *numbers;

   /* Initial memory allocation */
        numbers = (int *) malloc( idx * sizeof( int ) );    

        /* 
            process/use lines in array as needed
            (simple print all lines example below)
        */

        char *endptr[ idx ]; 
        int count = 0;
        for ( it = 0; it < idx; it++ )   
        {
            numbers[ it ] = strtol( array[ it ], &endptr[ it ], 0 ); 
            //numbers[ it ] = it+1; 
        }
        printf ("\n");
        for ( it = 0; it < idx; it++ )        /* free array memory    */
            free ( array[ it ] );
        free ( array );                       /* free array */
           
        return numbers;
}

int main( int argc, char **argv )
{
    int character;                      // character which is passed from command line
    int option_index = 0;               // the index of options
    char *option_to_argument_lock;       // it is the algorithm option, that is merge or quick sort
    char read_write_lock[ 8 ] = "rw_lock";     // for comparing the option to argument alg is merge
    char fine_grained_lock[ 8 ] = "fg_lock";     // for comparing the option to argument alg is quick 

    /*maintains the long option list of arguments passes in the command line*/
    static struct option long_options[] =  {
                                                { "put_file", 1, 0, 'p' },
                                                { "get_file", 1, 0, 'g' },
                                                { "lock", 1, 0, 'l' },
                                                { "range_file", 1, 0, 'r' },
                                                { "help", 0, 0, 'h' },
                                                { "name", 0, 0, 'n' },
						                        { "thread", 1, 0, 't' },
                                                { 0, 0, 0, 0 }
                                            };
    /*checks if all characters or aguments passed in the command line have been read*/
    while (( character = getopt_long( argc, argv, "l:p:g:r:t:hn", long_options, &option_index )) != -1 )
    {
        switch( character )
        {
            case 'l':                   // checks if alg is passed
            {
                printf( "\n--alg-> option = %s\n", optarg ); //prints the algorithm option which is merge or quick
                option_to_argument_lock = optarg;             //optarg maintains the argument
                                                             //strcmp the value of option passed to --alg is merge
                if ( strcmp( option_to_argument_lock, read_write_lock ) == 0 )
                {
                    int i,j;
                    rw_lock_flag = 1;                          // merge flag is set
                }  
                                                             // strcmp the value of option passed to --alg is quick
                else if ( strcmp( option_to_argument_lock, fine_grained_lock ) == 0 ) 
                {
                    fg_lock_flag = 1;                          // quick flag is set
                }
                break;
            }

            case 'h':                    // checks if --name argument is passed and prints the name of the user
            {
                printf( "\nUSAGE: ./binary_search_tree -p [file to put key, value] -g [file to get value based on key] -r [file which takes start and end key and return values in between] -t [Number of threads] --lock=[rw lock or fine grained lock]\n" );
                break;
            }
            case 'g':                     // checks if -o argument is passed and stores the file to be sorted in sorted_file
            {
                get_file = optarg;
                printf( "\n-g-> option = %s\n", optarg );

                
                break;
            }
            case 'p':                     // checks if -o argument is passed and stores the file to be sorted in sorted_file
            {
                put_file = optarg;
                printf( "\n-p-> option = %s\n", optarg );
                
                break;
            }
            case 'r':                     // checks if -o argument is passed and stores the file to be sorted in sorted_file
            {
                range_file = optarg;
                printf( "\n-r-> option = %s\n", optarg );
                
                
                break;
            }
            case 'n':                    // checks if --name argument is passed and prints the name of the user
            {
                printf( "\nHARSH RATHORE\n" );
                break;
            }

            case 't':
            {
                thread_count = atoi(optarg); //checks -t argument and adds thread count to thread_count
                printf( "The number of threads is %s",optarg );
                
                break;
            }

            case '?':                   // checks if no argument is passed to option which requires an argument
            {  
                if ( optopt == 'g' )
                    printf( "Option %c requires an argument which is the file where key and value will be inserted", optopt );
                else if ( optopt == 'p' )
                    printf( "Option %c requires an argument which is the file where the node based on the key will be returned", optopt );
                else if ( optopt == 'r' )
                    printf( "Option %c requires an argument which is the file where the range of nodes between two different keys will be returned", optopt );
               
                else if ( optopt == 't' )
                    thread_count = 5;           /* if no option specified take thread as 5 */
                    
                break;
            }
            default:                    // checks for unkown character
                printf( " returned character %c optopt = %c",character, optopt );
        }
    }

    if ( thread_count <= 0 )
        thread_count = 10;
    else if ( thread_count > 150 )
    {
        printf( "\nERROR: Too many threads\n");
        exit( -1 );
    }
    
    size_t args[thread_count];

    pthread_t threads[thread_count];

    if ( fg_lock_flag == 1 )
    {
        // pthread_mutex_init(&global_lock,NULL);

        // pthread_mutex_init(&fg_lock, NULL);
        pthread_mutex_init(&lock_fg_function, NULL);
        fg_lock_flag = 0;                            // flag is made zero
        int *numbers_put;                              // the unsorted file is read
        numbers_put = file(put_file);                          // read the file into the array
        int number_of_put = idx;
        printf( "number_of_put put %d\n",number_of_put );
        idx = 0;
        free(numbers_put);
        int *numbers_range;                              // the unsorted file is read
        numbers_range = file(range_file);                          // read the file into the array
        int number_of_range = idx;
        printf( "number_of_range range %d\n",number_of_range );
        idx = 0;
        free(numbers_range);
        int *numbers_get;                              // the unsorted file is read
        numbers_get = file(get_file);                          // read the file into the array
        int number_of_get = idx;
        printf( "number_of_get get %d\n\n",number_of_get );
        free(numbers_get);
        
        // tree=(Tree*)malloc(sizeof(Tree));
        //  // pthread_mutex_init(&tree->root->lock, NULL);
        // pthread_mutex_init(&tree->lock, NULL);
        // tree->root = NULL;
        // for (int i = 1; i < 20; i++)
	    // {
        //     insert(tree, i, i+100);
        // }
        // printf("count_put_lock=%d\n\n", count_lock);
        // deleteid(tree, 4, 40);
        // deleteid(tree,1, 10);
        // print_nodes_inorder(tree->root);
        // printf("\ncount_put_lock=%d\n", count_lock);

        // Node* node = get(tree, 5);
            
        // printf("key %d has value %d\n",node->key,node->value);

        // Node* node1 = get(tree, 7);
            
        // printf("key %d has value %d\n",node1->key,node1->value);


        // Node* node2 = get(tree, 9);
            
        // printf("key %d has value %d\n",node2->key,node2->value);

        // printf("count_get_lock=%d\n", count_lock_get);

        // info_fg_range_between_start_and_end(tree, 2, 10);
    	// printf("\n\n Range querry result:\n");
		// for (int i = 0; i < 2; i++) 
        // {
		// 	for (int j = 0; j < range_info_fg_function[i].size(); j++) 
        //     {
		// 		printf("Range Querry by thread %d for %d to %d = %d\n",i, range_info_fg_function[i][j].key_begin, range_info_fg_function[i][j].key_last, range_info_fg_function[i][j].node->key);
		// 	}
		// }

        tree=(Tree*)malloc(sizeof(Tree));
            
        pthread_mutex_init(&tree->lock, NULL);
        tree->root = NULL;
        if (number_of_put < thread_count) 
        {
            thread_count = (number_of_put / 2);
        }

        if (thread_count < 10) 
        {
            thread_count = 11;
        }

        data_thread_iterations th_info[thread_count];
        pthread_t th[thread_count];
        int i = 0;
        
        int size_of_task = (number_of_put / (thread_count - 4));
        printf("size_of_task:%d\n",size_of_task);
        printf("thread_count:%d\n",thread_count);
        int item_key = 0, iterations = 0;


		for (i = 0; i < (thread_count - 4); i++) 
        {
			item_key = i*size_of_task;
			if (i == (thread_count - 5)) 
            {
                th_info[i].iteration_length = (number_of_put - item_key);
				th_info[i].iteration_number = i;
				th_info[i].iteration_item = item_key;
			} 
            else 
            {
                th_info[i].iteration_length = size_of_task;
				th_info[i].iteration_number = i;				
				th_info[i].iteration_item = item_key;
			}

			//invoke the put threads
			if (pthread_create(&th[i], NULL, put_handler, (void *)&th_info[i]) != 0) 
			{
				printf("Error on creating the thread\n");
				exit(0);
			} 
            else 
            {
				//printf("Create new insert thread %d with length %d and start key %d\n", th_info[i].iteration_number, th_info[i].iteration_length, th_info[i].iteration_item);
			}
		}

		// for (i = 0; i < thread_count-4; i++) 
        // {
		// 	pthread_join(th[i], NULL);
		// }
		size_of_task = (number_of_get/ 2);
		item_key = 0;
		iterations = 0;

		for (; i < (thread_count - 2); i++) 
        {
			item_key = iterations*size_of_task;

			if (i == (thread_count - 3)) 
            {
                th_info[i].iteration_length = (number_of_get - item_key);
				th_info[i].iteration_number = i;				
				th_info[i].iteration_item = item_key;
			} 
            else 
            {
                th_info[i].iteration_length = size_of_task;
				th_info[i].iteration_number = i;				
				th_info[i].iteration_item = item_key;
			}

			//invoke the get threads
			if (pthread_create(&th[i], NULL, get_handler, (void *)&th_info[i]) != 0) 
            {
					printf("Error on creating the thread\n");
					exit(0);
			} 
            else 
            {
				//printf("Create new search thread %d with length %d and start key %d\n", th_info[i].iteration_number, th_info[i].iteration_length, th_info[i].iteration_item);
			}
			iterations++;
		}

		// for (i = thread_count-4; i < thread_count -2; i++) 
        // {
		// 	pthread_join(th[i], NULL);
		// }
		size_of_task = (number_of_range/ 2);
		item_key = 0;
		iterations = 0;
		for (; i < (thread_count); i++) 
        {
			// strcpy(th_info[i].filename, range_file);
			item_key = iterations*size_of_task;

			if (i == (thread_count - 1)) 
            {
                th_info[i].iteration_length = (number_of_range - item_key);
				th_info[i].iteration_number = iterations;				
				th_info[i].iteration_item = item_key;
			} 
            else 
            {
                th_info[i].iteration_length = size_of_task;
				th_info[i].iteration_number = iterations;				
				th_info[i].iteration_item = item_key;
			}

			//invoke the range querry threads
			if (pthread_create(&th[i], NULL, range_handler, (void *)&th_info[i]) != 0) 
            {
					printf("Error on creating the thread\n");
					exit(0);
			} 
            else 
            {
				//printf("Create new range querry thread %d with length %d and start key %d\n", th_info[i].iteration_number, th_info[i].iteration_length, th_info[i].iteration_item);
			}
			iterations++;
		}

		for (i = 0; i < thread_count; i++) 
        {
			pthread_join(th[i], NULL);
		}

        printf("\n\n Range querry result:\n");
		for (int i = 0; i < 2; i++) 
        {
			for (int iterations = 0; iterations < range_info_fg_function[i].size(); iterations++) 
            {
				printf("Range Querry by thread %d for %d to %d = %d\n",i, range_info_fg_function[i][iterations].key_begin, range_info_fg_function[i][iterations].key_last, range_info_fg_function[i][iterations].node->key);
			}
		}
        print_nodes_inorder(tree->root);





		// clock_gettime(CLOCK_MONOTONIC,&end1);

		// pthread_mutex_destroy(&lock_fg_function);
        //binary_search_tree_node* root = NULL; 
    //     	for (int i = 0; i < 15; i++)
	// {
	// 	//fscanf(fp, "%d %d\n", &key, &value);
	// 	put(tree, i+10, i+20);
	// }	
    //     put(root, 50, 1,0 ); 
    //  put(root, 30, 2,0 ); 
    //    put(root, 20, 3,0 ); 
    //     put(root, 40, 4,0 ); 
    //     put(root, 70, 5,0 ); 
    //    put(root, 60, 6,0 ); 
    //  put(root, 80, 7,0 );
       // print_nodes_inorder(tree->root);
    //     Node * node = NULL;
    //    	for (int i = 0; i < 15; i++)
	// {

	// 	node = get(NULL, i+10);
	// 	if (node == NULL) {
	// 		printf("Error: The key %d is not present\n", i+10);
	// 	} else {
	// 		printf("The key %d has value %d\n", node->key, node->value);
	// 	}	
	// 	node = NULL;
	// }
        // int low = 0;
        // FJ_Merge thread_array_merge[idx];           // structure for task merge for different threads
        // individual_thread_array_length = idx/thread_count; 

        // for ( i = 1; i < thread_count; i++ )
        // {
        //     low += individual_thread_array_length;
        //     args[ i ] = i + 1;
        //     printf( " Creating thread %zu\n", args[ i ] );
        //     if ( i != ( thread_count - 1 ) )                        // values of low index, high index, thread number and assigning the merge array
        //     {
        //         thread_array_merge[ i ].low_array_index_m = low ;
        //         thread_array_merge[ i ].high_array_index_m = low + individual_thread_array_length -1;
        //         thread_array_merge[ i ].thread_array = numbers;
        //         thread_array_merge[ i ].thread_number_merge = args[ i ];
        //     }
        //     else                                                    // values of low index, high index, thread number and assigning the merge array
        //     {
        //         thread_array_merge[ i ].low_array_index_m = low ;
        //         thread_array_merge[ i ].high_array_index_m =  idx - 1;
        //         thread_array_merge[ i ].thread_array = numbers;
        //         thread_array_merge[ i ].thread_number_merge = args[ i ];
        //     }

        //     ret = pthread_create( &threads[ i ], NULL, &mergesort_thread, &thread_array_merge[ i ]); // create p_threads 
        //     if ( ret )
        //     {
        //         printf( "ERROR: pthread_create: %d\n", ret);
        //         exit( -1 );
        //     }
        // }

        // thread_array_merge[ 0 ].low_array_index_m = 0;                                  // strutrue elements for main thread
        // thread_array_merge[ 0 ].high_array_index_m = individual_thread_array_length -1;
        // thread_array_merge[ 0 ].thread_array = numbers;
        // thread_array_merge[ 0 ].thread_number_merge = 1;
        // mergesort_thread( &thread_array_merge[ 0 ] );                                   // calling function for main

        // for ( size_t i = 1; i < thread_count; i++ )
        // {
        //     ret = pthread_join( threads[ i ], NULL );                                   // joining p_threads
        //     if ( ret )
        //     {
        //         printf( "ERROR: pthread_join: %d\n",ret );
        //         exit( -1 );
        //     }
        //     printf( "Joined thread %zu\n", i + 1 );
        // }

        // FJ_Merge *tskm = &thread_array_merge[0];                                        // merge sub arrays one by one such that we get final merge array
		// for (i = 1; i < thread_count; i++) {
		// 	FJ_Merge *tsk = &thread_array_merge[i];
		// 	merge(tsk->thread_array, tskm->low_array_index_m, tsk->low_array_index_m - 1, tsk->high_array_index_m);
		// }

        //clock_gettime(CLOCK_MONOTONIC,&end_time);
		// pthread_barrier_destroy(&bar);
        
        // FILE *ptri;
        // ptri = fopen( sorted_file, "w" );         // the file is opened in write mode which is passes to -o option
        // for (it = 0; it < idx; it++) 
        // {
        //     fprintf( ptri ,"%u\n", numbers[ it ] ); //the unsorted file is sorted and elements are stored in sorted file
        // }
        // if ( ptri ) 
        //     fclose ( ptri );                        /* close file */
        //free( numbers );                            //free numbers pointer
        // pthread_mutex_destroy(&fg_lock);

        pthread_mutex_destroy(&lock_fg_function);
        pthread_mutex_destroy(&tree->lock);
        // free(non_option_argument);
        // free(put_file);
        // free(get_file);
        // free(range_file);
        // free(tree);
        // free(tree->root);
        // free_all_nodes_in_bst(tree->root);
    }
    else if ( rw_lock_flag == 1 )    
    {
        rw_lock_flag = 0;

        int *numbers_put;                              // the unsorted file is read
        numbers_put = file(put_file);                          // read the file into the array
        int number_of_put = idx;
        printf( "number_of_put put %d\n",number_of_put );
        idx = 0;
        // free(numbers_put);
        int *numbers_range;                              // the unsorted file is read
        numbers_range = file(range_file);                          // read the file into the array
        int number_of_range = idx;
        printf( "number_of_range range %d\n",number_of_range );
        idx = 0;
        // free(numbers_range);
        int *numbers_get;                              // the unsorted file is read
        numbers_get = file(get_file);                          // read the file into the array
        int number_of_get = idx;
        printf( "number_of_get get %d\n",number_of_get );

    //     tree_rw=(Tree_rw*)malloc(sizeof(Tree_rw));
    //     pthread_rwlock_init(&tree_rw->lock, NULL);
    //     pthread_rwlock_init(&lock_rw_function, NULL);
    // //        pthread_mutex_init(&tree->lock, NULL);
    //     tree_rw->root = NULL;
    //     insert_rw(tree_rw, 1, 10);
    //     insert_rw(tree_rw,2, 20);
    //     // deleteid(tree, 1, 10);
    //     insert_rw(tree_rw,2, 30);
    //     insert_rw(tree_rw, 1, 10);
    //     insert_rw(tree_rw, 1, 100);
    //     insert_rw(tree_rw, 1, 200);
    //     insert_rw(tree_rw, 1, 500);
    //     deleteid_rw(tree_rw, 2,50);
    //     for (int i =0 ; i<15; i++)
    //     {
    //         insert_rw(tree_rw, i+10, i+100);
    //     }
    //     deleteid_rw(tree_rw, 12,50);
    //     deleteid_rw(tree_rw, 15,50);
    //     print_nodes_inorder_rw(tree_rw->root);
    //     Node_rw* nod = get_rw(tree_rw, 1);
    //     printf("key %d has value %d",nod->key,nod->value);
    //     info_range_between_start_and_end_rw(tree_rw, 1, 20);
    // 	printf("\n\n Range querry result for read write lock:\n");
	// 	for (int i = 0; i < 2; i++) {
	// 		for (int j = 0; j < range_info_rw_function[i].size(); j++) {
	// 			printf("Range Querry by thread %d for %d to %d = %d\n",i, range_info_rw_function[i][j].key_begin, range_info_rw_function[i][j].key_last, range_info_rw_function[i][j].node->key);
	// 		}
	// 	}


        // int *number;                             // the unsorted file is read
        // number = file();
        // quickSort( number, 0, idx - 1 );         // quicksort is done on unsorted list
        // FILE *ptr;
        // ptr = fopen( sorted_file, "w" );         // the file is opened in write mode which is passes to -o option
        // for ( it = 0; it < idx; it++ ) 
        // {
        //     fprintf( ptr, "%u\n", number[ it ] ); //the unsorted file is sorted and elements are stored in sorted file
        // }
        // if ( ptr ) 
        //     fclose ( ptr );                        /* close file */
        //free( number );                            //free number

	if (thread_count < 6)
    {
		thread_count = 6;
	}
	data_thread_iterations th_info[thread_count];
	pthread_t th[thread_count];
	int i = 0;
	
	int size_of_task = (number_of_put / (thread_count - 4));

	int item_key = 0, iterations = 0;

        tree_rw=(Tree_rw*)malloc(sizeof(Tree_rw));
        pthread_rwlock_init(&tree_rw->lock, NULL);
        pthread_rwlock_init(&lock_rw_function, NULL);
        tree_rw->root = NULL;

        if (number_of_put < thread_count) 
    {
		thread_count = (number_of_put / 2);
	}




	//check if the lock is set to rw_lock
	// if (arg.is_rw_lock_set != true) {

		// pthread_mutex_init(&lock_fg_function, NULL);
		// clock_gettime(CLOCK_MONOTONIC,&start);

		for (i = 0; i < (thread_count - 4); i++) {

			item_key = i * size_of_task ;
            printf("size_of_task_rw = %d \n",size_of_task);
            printf("item_key_rw = %d \n",item_key);
            printf("i_rw = %d \n",i);
			// strcpy(th_info[i].filename, put_file);

			if (i == (thread_count - 5)) 
            {
                th_info[i].iteration_length = (number_of_put - item_key);
				th_info[i].iteration_number = i;				
				th_info[i].iteration_item = item_key;
			} 
            else 
            {
                th_info[i].iteration_length = size_of_task;
				th_info[i].iteration_number = i;				
				th_info[i].iteration_item = item_key;
			}

			//invoke the put threads
			if (pthread_create(&th[i], NULL, put_handler_rw, (void *)&th_info[i]) != 0) 
			{
				printf("Error on creating the thread\n");
				exit(0);
			} 
            else 
            {
				//printf("Create new insert thread %d with length %d and start key %d\n", th_info[i].iteration_number, th_info[i].iteration_length, th_info[i].iteration_item);
			}
		}

		size_of_task = (number_of_get/ 2);
		item_key = 0;
		iterations = 0;

		for (; i < (thread_count - 2); i++) 
        {
			// strcpy(th_info[i].filename, get_file);
			item_key = iterations*size_of_task;
            printf("size_of_task_rw_1 = %d \n",size_of_task);
            printf("item_key_rw_1 = %d \n",item_key);
            printf("i_rw_1 = %d \n",i);
            printf("iterations_rw_1 = %d \n",iterations);

			if (i == (thread_count - 3)) 
            {
                th_info[i].iteration_length = (number_of_get - item_key);
				th_info[i].iteration_number = i;				
				th_info[i].iteration_item = item_key;
			} 
            else 
            {
                th_info[i].iteration_length = size_of_task;
				th_info[i].iteration_number = i;				
				th_info[i].iteration_item = item_key;
			}

			//invoke the get threads
			if (pthread_create(&th[i], NULL, get_handler_rw, (void *)&th_info[i]) != 0) 
            {
					printf("Error on creating the thread\n");
					exit(0);
			} 
            else 
            {
				//printf("Create new search thread %d with length %d and start key %d\n", th_info[i].iteration_number, th_info[i].iteration_length, th_info[i].iteration_item);
			}
			iterations++;
		}

		size_of_task = (number_of_range/ 2);
		item_key = 0;
		iterations = 0;
		for (; i < (thread_count); i++) 
        {

			// strcpy(th_info[i].filename, range_file);
			item_key = iterations*size_of_task;
            printf("size_of_task_rw_2 = %d \n",size_of_task);
            printf("item_key_rw_2 = %d \n",item_key);
            printf("i_rw_2 = %d \n",i);
            printf("iterations_rw_2 = %d \n",iterations);
			if (i == (thread_count - 1)) 
            {
                th_info[i].iteration_length = (number_of_range - item_key);
				th_info[i].iteration_number = iterations;				
				th_info[i].iteration_item = item_key;
			} 
            else 
            {
                th_info[i].iteration_length = size_of_task;
				th_info[i].iteration_number = iterations;				
				th_info[i].iteration_item = item_key;
			}

			//invoke the range querry threads
			if (pthread_create(&th[i], NULL, range_handler_rw, (void *)&th_info[i]) != 0) 
            {
					printf("Error on creating the thread\n");
					exit(0);
			} 
            else 
            {
				//printf("Create new range querry thread %d with length %d and start key %d\n", th_info[i].iteration_number, th_info[i].iteration_length, th_info[i].iteration_item);
			}
			iterations++;
		}

		for (i = 0; i < thread_count; i++) 
        {
			pthread_join(th[i], NULL);
		}

            		printf("\n\n Range querry result rw:\n");
		for (int i = 0; i < 2; i++) 
        {
			for (int iterations = 0; iterations < range_info_rw_function[i].size(); iterations++) 
            {
				printf("Range Querry by thread %d for %d to %d = %d\n",i, range_info_rw_function[i][iterations].key_begin, range_info_rw_function[i][iterations].key_last, range_info_rw_function[i][iterations].node->key);
			}
		}
        print_nodes_inorder_rw(tree_rw->root);

    }

    // unsigned long long elapsed_ns;
	// elapsed_ns = (end_time.tv_sec-start.tv_sec)*1000000000 + (end_time.tv_nsec-start.tv_nsec);
	// printf("Elapsed (ns): %llu\n",elapsed_ns);
	// double elapsed_s = ((double)elapsed_ns)/1000000000.0;
	// printf("Elapsed (s): %lf\n",elapsed_s);

    return 0;
}






